// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.4
// LVGL version: 8.3.11
// Project name: CNC_HMI

#include "ui.h"
#include "screens/ui_seleccionarTarea.h"
#include "../mqtt/mqtt_service.h"
#include "../files/file_manager.h"
#include "../logger/logger.h"
#include "../websocket/fluidnc_formatter.h"
#include "../websocket/websocket_cmd.h"
#include "ui_logic.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int maquina_activa_id = 1;
extern FileList mis_archivos;

// --- HELPER ---
void enviar_orden_cnc(const char* comando) {
    char topico_id[32];
    sprintf(topico_id, "maquina_%d", maquina_activa_id);
    // mqtt_send_command(topico_id, comando);

    char log[64];
    snprintf(log, 64, "M%d: %s", maquina_activa_id, comando);
    ui_add_log(log);

    const char *ip="192.168.211.243:81"; // IP fija por ahora
    run_websocket_cmd(ip, comando);
}

// --- LÓGICA DE ARCHIVOS ---

// Función auxiliar para leer el estado de la DB (escrito por Python)
int verificar_estado_db() {
    FILE *f = fopen("db_status.txt", "r");
    if (!f) return 0; // Asumimos error si no existe

    char buffer[16];
    if (fgets(buffer, sizeof(buffer), f)) {
        fclose(f);
        if (strstr(buffer, "OK")) return 1;
    } else {
        fclose(f);
    }
    return 0; // Error
}

void RefrescarListaArchivos(lv_event_t * e) {
    lv_obj_t * lista = ui_listaTareas1;

    if (!lista) {
        printf("[UI ERROR] No encuentro la lista de tareas.\n");
        return;
    }

    lv_obj_clean(lista); // Limpiar lista visual

    // 1. VERIFICAR CONEXIÓN A LA DB PRIMERO
    if (verificar_estado_db() == 0) {
        // Si Python dijo "ERROR", mostramos esto y salimos
        lv_list_add_text(lista, "Sin conexion con la DB");
        return;
    }

    // 2. Si hay conexión, escaneamos la carpeta
    fm_scan_directory(&mis_archivos);

    if (mis_archivos.count == 0) {
        lv_list_add_text(lista, "Sin tareas asignadas");
    } else {
        for(int i=0; i<mis_archivos.count; i++) {
            // Usamos List Button para mostrar los archivos
            lv_obj_t * btn = lv_list_add_btn(lista, LV_SYMBOL_FILE, mis_archivos.filenames[i]);
            // El evento de clic se asigna (si lo tenías separado o usas el genérico)
            // lv_obj_add_event_cb(btn, EventoClickArchivo, LV_EVENT_CLICKED, NULL);
        }
    }
}

// ... (El resto de funciones agregar_tarea, retrocederMain, etc. se mantienen IGUAL) ...
void agregar_tarea(lv_event_t * e) {
    if (ui_seleccionarTarea) {
        _ui_screen_change(&ui_seleccionarTarea, LV_SCR_LOAD_ANIM_NONE, 0, 0, &ui_seleccionarTarea_screen_init);
        RefrescarListaArchivos(NULL);
    }
}

void retrocederMain(lv_event_t * e) {
    _ui_screen_change(&ui_main, LV_SCR_LOAD_ANIM_FADE_ON, 200, 0, &ui_main_screen_init);
}

// Asignar tarea seleccionada en lista
void asignar_tarea(lv_event_t * e) {
    // Lógica simplificada: Asumimos que si dio click es el correcto
    printf("[UI] Tarea asignada.\n");
    retrocederMain(NULL);
}

// --- EVENTOS DE MOVIMIENTO (JOG) IGUALES QUE ANTES ---
void mover_x_pos(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('X',10, 7000, output);
    enviar_orden_cnc(output);

}

void mover_x_neg(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('X',-10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_y_pos(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Y',10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_y_neg(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Y',-10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_z_pos(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Z',10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_z_neg(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Z',-10, 7000, output);
    enviar_orden_cnc(output); 

}

void iniciarCorte(lv_event_t * e) { 
    
    // enviar_orden_cnc("'SD/Run=espiral.nc'"); 
    enviar_orden_cnc("$LocalFS/Run=espiral.nc"); 
}

void pauseMachine(lv_event_t * e) { 
    
    enviar_orden_cnc("PAUSE"); 
}

void home_positions(lv_event_t * e) { 
    
    enviar_orden_cnc("HOME"); 
}

void parado_de_emergencia(lv_event_t * e) { 
    
    enviar_orden_cnc("STOP"); 
}

void parado_total(lv_event_t * e) { mqtt_send_command("todas", "EMERGENCIA"); ui_add_log("PARO TOTAL"); }
void listar_maquinas(lv_event_t * e) {
    lv_obj_t * roller = lv_event_get_target(e);
    maquina_activa_id = lv_roller_get_selected(roller) + 1;
    char buf[32]; snprintf(buf, 32, "Sel: M%d", maquina_activa_id);
    ui_add_log(buf);
}
