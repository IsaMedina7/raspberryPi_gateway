// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.4
// LVGL version: 8.3.11
// Project name: CNC_HMI

#include "ui.h"
#include "screens/ui_seleccionarTarea.h"
#include "../mqtt/mqtt_service.h"
#include "../files/file_manager.h"
#include "../logger/logger.h"
#include "../websocket/websocket_cmd.h" // Tu librería de WS
#include "../websocket/fluidnc_formatter.h"
#include "ui_logic.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void ui_update_ip_display(const char * ip);

// --- CONFIGURACIÓN DE MÁQUINAS FIJAS ---
// Aquí defines tus máquinas manualmente
typedef struct {
    int id;
    const char* nombre;
    const char* ip;
} MaquinaFija;

// LISTA DE MÁQUINAS (Edita las IPs aquí)
MaquinaFija maquinas_fijas[] = {
    {1, "CNC 01 (Fresadora)", "10.213.126.243"}, // <--- IP MAQUINA 1
    {2, "CNC 02 (Torno)",     "192.168.1.51"}  // <--- IP MAQUINA 2
};
int total_maquinas_fijas = 2;

// Variables Globales
int maquina_activa_id = 1;      // ID seleccionado (1, 2...)
char ip_maquina_objetivo[32] = ""; // IP seleccionada
extern FileList mis_archivos;

// --- HELPER: BUSCAR IP ---
const char* obtener_ip_por_id(int id) {
    for(int i=0; i<total_maquinas_fijas; i++) {
        if(maquinas_fijas[i].id == id) {
            return maquinas_fijas[i].ip;
        }
    }
    return ""; // No encontrada
}

// --- FUNCIÓN DE INICIO: LLENAR ROLLER (Llamar al iniciar) ---
void ActualizarRollerMaquinas(void) {
    // CAMBIA 'ui_listMaquinas' POR EL NOMBRE REAL DE TU ROLLER DE MÁQUINAS (EN DASHBOARD)
    lv_obj_t * roller = ui_listMaquinas;

    if (!roller) return;

    char opciones[1024] = "";
    int count = 0;

    for(int i=0; i<MAX_MAQUINAS; i++) {
        if (global_state.maquinas[i].activa) {
            char linea[64];
            // Mostrar "M1 - 192.168.1.50"
            if (strlen(global_state.maquinas[i].ip) > 0) {
                snprintf(linea, 64, "M%d - %s", global_state.maquinas[i].id, global_state.maquinas[i].ip);
            } else {
                snprintf(linea, 64, "Maquina %d", global_state.maquinas[i].id);
            }

            if (count > 0) strcat(opciones, "\n");
            strcat(opciones, linea);
            count++;
        }
    }

    if (count == 0) {
        lv_roller_set_options(roller, "Esperando maquinas...", LV_ROLLER_MODE_NORMAL);
    } else {
        lv_roller_set_options(roller, opciones, LV_ROLLER_MODE_NORMAL);
    }
}

// Esta función debe llamarse una vez al arrancar la UI
void InicializarListaMaquinas(void) {
    lv_obj_t * roller = ui_listMaquinas;
    if (!roller) return;

    char opciones[512] = "";

    // Construir string: "CNC 01\nCNC 02"
    for(int i=0; i<total_maquinas_fijas; i++) {
        strcat(opciones, maquinas_fijas[i].nombre);
        if (i < total_maquinas_fijas - 1) strcat(opciones, "\n");
    }

    lv_roller_set_options(roller, opciones, LV_ROLLER_MODE_NORMAL);

    // Seleccionar la primera por defecto
    lv_roller_set_selected(roller, 0, LV_ANIM_OFF);
    maquina_activa_id = maquinas_fijas[0].id;
    strcpy(ip_maquina_objetivo, maquinas_fijas[0].ip);

    // Actualizar Label de IP
    ui_update_ip_display(ip_maquina_objetivo);
}

// --- EVENTO: AL CAMBIAR EL ROLLER ---
void listar_maquinas(lv_event_t * e) {
    lv_obj_t * roller = lv_event_get_target(e);
    int index = lv_roller_get_selected(roller); // 0, 1...

    // Actualizar ID y IP según el array fijo
    if (index < total_maquinas_fijas) {
        maquina_activa_id = maquinas_fijas[index].id;
        strcpy(ip_maquina_objetivo, maquinas_fijas[index].ip);

        // Logs y Visualización
        char buf[64];
        snprintf(buf, 64, "Sel: %s (%s)", maquinas_fijas[index].nombre, ip_maquina_objetivo);
        ui_add_log(buf);

        ui_update_ip_display(ip_maquina_objetivo);
    }
}

// --- HELPER DE ENVÍO (WEBSOCKET) ---
void enviar_orden_cnc(const char* comando) {
    if (strlen(ip_maquina_objetivo) == 0) {
        ui_add_log("ERROR: Sin IP de destino");
        return;
    }

    char ip_con_puerto[40];
    snprintf(ip_con_puerto, 40, "%s:81", ip_maquina_objetivo); // Puerto WebSocket estándar

    // Llamada a tu función de WebSocket
    run_websocket_cmd(ip_con_puerto, comando);

    // Log visual
    char log[64];
    snprintf(log, 64, "M%d TX: %s", maquina_activa_id, comando);
    ui_add_log(log);
}

// --- RESTO DE EVENTOS (Archivos y Movimiento) ---
// Función auxiliar para leer el estado de la DB (escrito por Python)
int verificar_estado_db() {
    FILE *f = fopen("db_status.txt", "r");
    if (!f) return 0; // Asumimos error si no existe

    char buffer[16];
    if (fgets(buffer, sizeof(buffer), f)) {
        fclose(f);
        if (strstr(buffer, "OK")) return 1;
    } else {
        fclose(f);
    }
    return 0; // Error
}

void RefrescarListaArchivos(lv_event_t * e) {
    lv_obj_t * roller = ui_listaTareas1;

    if (!roller) {
        printf("[UI ERROR] El objeto Roller no existe aún.\n");
        return;
    }

    // 1. Escanear archivos
    fm_scan_directory(&mis_archivos);

    if (mis_archivos.count == 0) {
        lv_roller_set_options(roller, "Sin archivos", LV_ROLLER_MODE_NORMAL);
        return;
    }

    // 2. Construir la cadena gigante de forma segura (Memoria Dinámica)
    // Calculamos el tamaño necesario aprox: 64 chars por archivo * cantidad
    size_t buffer_size = mis_archivos.count * 65;
    char *opciones = (char*)malloc(buffer_size); // Pedimos memoria al sistema

    if (opciones == NULL) {
        printf("[UI CRITICO] No hay memoria para listar archivos.\n");
        return;
    }

    // Limpiamos el buffer
    opciones[0] = '\0';

    for(int i=0; i < mis_archivos.count; i++) {
        strcat(opciones, mis_archivos.filenames[i]);

        // Agregar salto de línea si no es el último
        if (i < mis_archivos.count - 1) {
            strcat(opciones, "\n");
        }
    }

    // 3. Asignar al Roller
    lv_roller_set_options(roller, opciones, LV_ROLLER_MODE_NORMAL);

    // 4. Liberar la memoria temporal (¡Muy importante!)
    free(opciones);

    printf("[UI] Roller actualizado con %d archivos.\n", mis_archivos.count);
}


// ... (El resto de funciones agregar_tarea, retrocederMain, etc. se mantienen IGUAL) ...
void agregar_tarea(lv_event_t * e) {
    system("python3 /home/merry/proyecto_cnc_hmi/src/aws/sync_cloud.py once");
    if (ui_seleccionarTarea) {
        _ui_screen_change(&ui_seleccionarTarea, LV_SCR_LOAD_ANIM_NONE, 0, 0, &ui_seleccionarTarea_screen_init);
        RefrescarListaArchivos(NULL);
    }
}

void retrocederMain(lv_event_t * e) {
    _ui_screen_change(&ui_main, LV_SCR_LOAD_ANIM_FADE_ON, 200, 0, &ui_main_screen_init);
}

void asignar_tarea(lv_event_t * e) {
    // 1. Obtener el objeto Roller
    lv_obj_t * roller = ui_listaTareas1;
    if (!roller) {
        ui_add_log("ERROR: No se encuentra la lista de tareas.");
        return;
    }

    // 2. Obtener el texto seleccionado (Nombre del archivo)
    char seleccion[128];
    lv_roller_get_selected_str(roller, seleccion, sizeof(seleccion));
    
    // 3. Validaciones básicas
    if (strlen(seleccion) == 0 || strcmp(seleccion, "Sin archivos") == 0 || strcmp(seleccion, "Vacio") == 0) {
        ui_add_log("ADVERTENCIA: Seleccione un archivo válido.");
        return; 
    }

    // --- CORRECCIÓN IP (Lógica momentánea) ---
    const char *ip_destino = NULL;
    // Calculamos el tamaño del array automáticamente
    int total_maquinas = sizeof(maquinas_fijas) / sizeof(maquinas_fijas[0]);

    // Buscamos la IP que corresponde al ID activo
    for (int i = 0; i < total_maquinas; i++) {
        if (maquinas_fijas[i].id == maquina_activa_id) {
            ip_destino = maquinas_fijas[i].ip;
            break; // Encontrado, salimos del bucle
        }
    }

    // Si no encontramos la IP, abortamos para evitar crash
    if (ip_destino == NULL) {
        ui_add_log("ERROR: No se encontró IP para la máquina activa.");
        return;
    }
    // ------------------------------------------

    // 4. Feedback en consola visual
    char log_msg[256];
    // Nota: cambié %d por %s en el log para mostrar la IP, o puedes dejar el ID si prefieres
    snprintf(log_msg, sizeof(log_msg), "Asignando '%s' a %s...", seleccion, ip_destino);
    ui_add_log(log_msg);
    
    // Forzamos actualización visual antes de bloquear (opcional pero recomendado)
    lv_task_handler(); 

    // 5. Construir ruta
    char path[256];
    snprintf(path, sizeof(path), "gcode_files/%s", seleccion);
    
    // CORRECCIÓN PRINCIPAL: Pasamos 'ip_destino' (cadena) en lugar del ID (entero)
    upload_file_to_sd(ip_destino, path, seleccion);

    // 6. Regresar al Dashboard automáticamente
    retrocederMain(NULL);
}

// --- EVENTOS DE MOVIMIENTO (JOG) IGUALES QUE ANTES ---
void mover_x_pos(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('X',10, 7000, output);
    enviar_orden_cnc(output);

}

void mover_x_neg(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('X',-10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_y_pos(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Y',10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_y_neg(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Y',-10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_z_pos(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Z',10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_z_neg(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Z',-10, 7000, output);
    enviar_orden_cnc(output); 

}

void iniciarCorte(lv_event_t * e) { 
    // 1. Obtener el objeto Roller
    lv_obj_t * roller = ui_listaTareas1;
    if (!roller) {
        // ui_add_log("ERROR: No se encuentra la lista de tareas.");
        return;
    }

    // 2. Obtener el texto seleccionado (Nombre del archivo)
    char seleccion[128];
    lv_roller_get_selected_str(roller, seleccion, sizeof(seleccion));
    
    // 3. Validaciones básicas
    if (strlen(seleccion) == 0 || strcmp(seleccion, "Sin archivos") == 0 || strcmp(seleccion, "Vacio") == 0) {
        ui_add_log("ADVERTENCIA: Seleccione un archivo válido.");
        return; 
    }
    char command[256];
    snprintf(command, sizeof(command), "$SD/Run=/%s", seleccion);
    
    // enviar_orden_cnc("'SD/Run=espiral.nc'"); 
    enviar_orden_cnc(command); 
}

void pauseMachine(lv_event_t * e) { 
    
    enviar_orden_cnc("PAUSE"); 
}

void home_positions(lv_event_t * e) { 
    
    enviar_orden_cnc("HOME"); 
}

void parado_de_emergencia(lv_event_t * e) { 
    
    enviar_orden_cnc("STOP"); 
}

void parado_total(lv_event_t * e) { mqtt_send_command("todas", "EMERGENCIA"); ui_add_log("PARO TOTAL"); }

