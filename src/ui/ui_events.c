// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.4
// LVGL version: 8.3.11
// Project name: CNC_HMI

#include "ui.h"
#include "screens/ui_seleccionarTarea.h"
#include "../mqtt/mqtt_service.h"
#include "../files/file_manager.h"
#include "../logger/logger.h"
#include "../websocket/fluidnc_formatter.h"
#include "../websocket/websocket_cmd.h"
#include "ui_logic.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int maquina_activa_id = 1;
extern FileList mis_archivos;
extern SystemState global_state;

// Variable global para que el WebSocket sepa a quién hablarle
char ip_maquina_objetivo[32] = "";
int id_maquina_objetivo = 0;

// --- FUNCIÓN PARA LLENAR EL ROLLER ---
void ActualizarRollerMaquinas(void) {
    // CAMBIA 'ui_listMaquinas' POR EL NOMBRE REAL DE TU ROLLER DE MÁQUINAS (EN DASHBOARD)
    lv_obj_t * roller = ui_listMaquinas;

    if (!roller) return;

    char opciones[1024] = "";
    int count = 0;

    for(int i=0; i<MAX_MAQUINAS; i++) {
        if (global_state.maquinas[i].activa) {
            char linea[64];
            // Mostrar "M1 - 192.168.1.50"
            if (strlen(global_state.maquinas[i].ip) > 0) {
                snprintf(linea, 64, "M%d - %s", global_state.maquinas[i].id, global_state.maquinas[i].ip);
            } else {
                snprintf(linea, 64, "Maquina %d", global_state.maquinas[i].id);
            }

            if (count > 0) strcat(opciones, "\n");
            strcat(opciones, linea);
            count++;
        }
    }

    if (count == 0) {
        lv_roller_set_options(roller, "Esperando maquinas...", LV_ROLLER_MODE_NORMAL);
    } else {
        lv_roller_set_options(roller, opciones, LV_ROLLER_MODE_NORMAL);
    }
}

// --- EVENTO AL SELECCIONAR EN EL ROLLER ---
void ui_event_listMaquinas(lv_event_t * e) {
    lv_obj_t * roller = lv_event_get_target(e);
    int selected_idx = lv_roller_get_selected(roller);

    // Buscar cuál máquina real corresponde al índice seleccionado
    // (Esto es simplificado, asumiendo orden 1, 2, 3...)
    // Lo ideal es volver a recorrer global_state para encontrar la "n-ésima" máquina activa

    int count = 0;
    for(int i=0; i<MAX_MAQUINAS; i++) {
        if (global_state.maquinas[i].activa) {
            if (count == selected_idx) {
                // ¡Encontrada! Guardamos su IP para usarla en WebSockets
                strncpy(ip_maquina_objetivo, global_state.maquinas[i].ip, 32);
                id_maquina_objetivo = global_state.maquinas[i].id;

                printf("[UI] Seleccionada M%d IP: %s\n", id_maquina_objetivo, ip_maquina_objetivo);

                // Actualizar Label de IP en la barra superior
                // (Si tienes la función ui_update_ip_display)
                // ui_update_ip_display(ip_maquina_objetivo);
                return;
            }
            count++;
        }
    }
}

// --- HELPER ---
void enviar_orden_cnc(const char* comando) {
    char topico_id[32];
    sprintf(topico_id, "maquina_%d", maquina_activa_id);
    // mqtt_send_command(topico_id, comando);

    char log[64];
    snprintf(log, 64, "M%d: %s", maquina_activa_id, comando);
    ui_add_log(log);

    const char *ip="192.168.211.243:81"; // IP fija por ahora
    run_websocket_cmd(ip, comando);
}

// --- LÓGICA DE ARCHIVOS ---

// Función auxiliar para leer el estado de la DB (escrito por Python)
int verificar_estado_db() {
    FILE *f = fopen("db_status.txt", "r");
    if (!f) return 0; // Asumimos error si no existe

    char buffer[16];
    if (fgets(buffer, sizeof(buffer), f)) {
        fclose(f);
        if (strstr(buffer, "OK")) return 1;
    } else {
        fclose(f);
    }
    return 0; // Error
}

void RefrescarListaArchivos(lv_event_t * e) {
    lv_obj_t * lista = ui_listaTareas1;

    if (!lista) {
        printf("[UI ERROR] No encuentro la lista de tareas.\n");
        return;
    }

    lv_obj_clean(lista); // Limpiar lista visual

    // 1. VERIFICAR CONEXIÓN A LA DB PRIMERO
    if (verificar_estado_db() == 0) {
        // Si Python dijo "ERROR", mostramos esto y salimos
        lv_list_add_text(lista, "Sin conexion con la DB");
        return;
    }

    // 2. Si hay conexión, escaneamos la carpeta
    fm_scan_directory(&mis_archivos);

    if (mis_archivos.count == 0) {
        lv_list_add_text(lista, "Sin tareas asignadas");
    } else {
        for(int i=0; i<mis_archivos.count; i++) {
            // Usamos List Button para mostrar los archivos
            lv_obj_t * btn = lv_list_add_btn(lista, LV_SYMBOL_FILE, mis_archivos.filenames[i]);
            // El evento de clic se asigna (si lo tenías separado o usas el genérico)
            // lv_obj_add_event_cb(btn, EventoClickArchivo, LV_EVENT_CLICKED, NULL);
        }
    }
}

// ... (El resto de funciones agregar_tarea, retrocederMain, etc. se mantienen IGUAL) ...
void agregar_tarea(lv_event_t * e) {
    if (ui_seleccionarTarea) {
        _ui_screen_change(&ui_seleccionarTarea, LV_SCR_LOAD_ANIM_NONE, 0, 0, &ui_seleccionarTarea_screen_init);
        RefrescarListaArchivos(NULL);
    }
}

void retrocederMain(lv_event_t * e) {
    _ui_screen_change(&ui_main, LV_SCR_LOAD_ANIM_FADE_ON, 200, 0, &ui_main_screen_init);
}

// Asignar tarea seleccionada en lista
void asignar_tarea(lv_event_t * e) {
    // Lógica simplificada: Asumimos que si dio click es el correcto
    printf("[UI] Tarea asignada.\n");
    retrocederMain(NULL);
}

// --- EVENTOS DE MOVIMIENTO (JOG) IGUALES QUE ANTES ---
void mover_x_pos(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('X',10, 7000, output);
    enviar_orden_cnc(output);

}

void mover_x_neg(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('X',-10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_y_pos(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Y',10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_y_neg(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Y',-10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_z_pos(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Z',10, 7000, output);
    enviar_orden_cnc(output); 

}

void mover_z_neg(lv_event_t * e) { 
    char output[FLUIDNC_CMD_MAX];
    fluidnc_format_jog('Z',-10, 7000, output);
    enviar_orden_cnc(output); 

}

void iniciarCorte(lv_event_t * e) { 
    
    // enviar_orden_cnc("'SD/Run=espiral.nc'"); 
    enviar_orden_cnc("$LocalFS/Run=espiral.nc"); 
}

void pauseMachine(lv_event_t * e) { 
    
    enviar_orden_cnc("PAUSE"); 
}

void home_positions(lv_event_t * e) { 
    
    enviar_orden_cnc("HOME"); 
}

void parado_de_emergencia(lv_event_t * e) { 
    
    enviar_orden_cnc("STOP"); 
}

void parado_total(lv_event_t * e) { mqtt_send_command("todas", "EMERGENCIA"); ui_add_log("PARO TOTAL"); }
void listar_maquinas(lv_event_t * e) {
    lv_obj_t * roller = lv_event_get_target(e);
    maquina_activa_id = lv_roller_get_selected(roller) + 1;
    char buf[32]; snprintf(buf, 32, "Sel: M%d", maquina_activa_id);
    ui_add_log(buf);
}
